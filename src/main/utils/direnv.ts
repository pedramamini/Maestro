import { execFileNoThrow } from './execFile';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import * as crypto from 'crypto';
import { getExpandedEnv } from './cliDetection';

// Cache detection results
let direnvInstalledCache: boolean | null = null;
let direnvPathCache: string | null = null;

export interface DirenvDetectionResult {
  detected: boolean;
  envFilePath?: string;
  warning?: string;
}

/**
 * Check if direnv is installed and cache the result.
 */
export async function isDirenvInstalled(): Promise<boolean> {
  if (direnvInstalledCache !== null) return direnvInstalledCache;

  const command = process.platform === 'win32' ? 'where' : 'which';
  const env = getExpandedEnv();
  const result = await execFileNoThrow(command, ['direnv'], undefined, env);

  if (result.exitCode === 0 && result.stdout.trim()) {
    direnvInstalledCache = true;
    direnvPathCache = result.stdout.trim().split('\n')[0];
  } else {
    direnvInstalledCache = false;
  }
  return direnvInstalledCache;
}

/**
 * Get the cached path to the direnv binary.
 */
export function getDirenvPath(): string | null {
  return direnvPathCache;
}

/**
 * Clear the direnv detection cache (for testing or re-detection).
 */
export function clearDirenvCache(): void {
  direnvInstalledCache = null;
  direnvPathCache = null;
}

/**
 * Detect direnv environment and generate CLAUDE_ENV_FILE script.
 *
 * Returns detection result with:
 * - detected: true if .envrc exists in cwd
 * - envFilePath: path to generated script (if direnv is installed and allowed)
 * - warning: user-facing message if setup is incomplete
 */
export async function detectDirenvEnvironment(cwd: string): Promise<DirenvDetectionResult> {
  // Check for .envrc in project
  const envrcPath = path.join(cwd, '.envrc');
  if (!fs.existsSync(envrcPath)) {
    return { detected: false };
  }

  // Check direnv is installed
  if (!(await isDirenvInstalled())) {
    return {
      detected: true,
      warning: 'direnv not installed - environment will not be activated',
    };
  }

  // Check .envrc is allowed (direnv status indicates allow state)
  const env = getExpandedEnv();
  const statusResult = await execFileNoThrow(
    direnvPathCache || 'direnv',
    ['status'],
    cwd,
    env
  );

  // direnv status includes "Found RC allowed" or "Loaded RC allowed" when .envrc is allowed
  const isAllowed =
    statusResult.stdout.includes('Found RC allowed') ||
    statusResult.stdout.includes('Loaded RC allowed');

  if (!isAllowed && statusResult.stdout.includes('Found RC')) {
    return {
      detected: true,
      warning: '.envrc not allowed - run `direnv allow` in project directory',
    };
  }

  // Generate env file script
  const envFilePath = await generateDirenvEnvFile(cwd);

  return {
    detected: true,
    envFilePath,
  };
}

/**
 * Generate a CLAUDE_ENV_FILE script for direnv integration.
 * Scripts are cached per-project in ~/.local/share/Maestro/direnv-scripts/
 */
async function generateDirenvEnvFile(cwd: string): Promise<string> {
  const hash = crypto.createHash('sha256').update(cwd).digest('hex').slice(0, 16);
  const scriptDir = path.join(os.homedir(), '.local', 'share', 'Maestro', 'direnv-scripts');
  const scriptPath = path.join(scriptDir, `${hash}.sh`);

  // Ensure directory exists
  fs.mkdirSync(scriptDir, { recursive: true });

  // Generate script (idempotent - overwrites if exists)
  const direnvPath = direnvPathCache || 'direnv';
  const escapedCwd = cwd.replace(/'/g, "'\\''");

  const script = `#!/usr/bin/env bash
# Auto-generated by Maestro for direnv integration
# Project: ${cwd}

# Only activate if we're in or under the project directory
case "$PWD" in
  '${escapedCwd}'|'${escapedCwd}'/*)
    eval "$(${direnvPath} export bash 2>/dev/null)"
    ;;
esac
`;

  fs.writeFileSync(scriptPath, script, { mode: 0o755 });
  return scriptPath;
}
