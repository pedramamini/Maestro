---
type: reference
title: VIBES Data Model Reference
created: 2026-02-10
tags:
  - vibes
  - data-model
  - reference
related:
  - "[[VIBES-Integration]]"
---

# VIBES Data Model Reference

This document provides a complete reference for the VIBES (Verified Instrumental Behavior and Environment Standard) v1.0 data model as implemented in Maestro. It covers assurance levels, annotation types, manifest entry types, hash computation rules, file format schemas, and Maestro-specific extensions.

## Assurance Levels

Assurance levels control the granularity of metadata captured during AI-assisted development sessions. The level is set globally via Maestro settings and applies to all instrumenters.

| Level | Description | Data Captured |
|---|---|---|
| **Low** | Minimal metadata; session boundaries only | Environment entries, session start/end records |
| **Medium** (default) | Balanced detail; suitable for most workflows | All from Low, plus: prompts with context files, command entries with output summaries, line/function annotations |
| **High** | Complete capture; full traceability | All from Medium, plus: reasoning/thinking chains, token counts per reasoning block, model identification on reasoning entries |

### Assurance Level Type

```typescript
type VibesAssuranceLevel = 'low' | 'medium' | 'high';
```

### What Each Level Excludes

- **Low**: Does not capture prompts, reasoning, or command output summaries.
- **Medium**: Does not capture reasoning/thinking chains or token-level statistics.
- **High**: Captures everything; no exclusions.

## Annotation Types

Annotations are the primary output of VIBES instrumentation. They are appended to `annotations.jsonl` and reference manifest entries by SHA-256 hash.

```typescript
type VibesAnnotationType = 'line' | 'function' | 'session';

type VibesAnnotation =
  | VibesLineAnnotation
  | VibeFunctionAnnotation
  | VibesSessionRecord;
```

### Line Annotation

Links a range of lines in a source file to provenance metadata. This is the most common annotation type, created whenever an AI agent modifies or reviews code.

```typescript
interface VibesLineAnnotation {
  type: 'line';
  file_path: string;               // Relative or absolute path to the file
  line_start: number;              // Starting line number (1-based)
  line_end: number;                // Ending line number (inclusive)
  environment_hash: string;        // SHA-256 of the environment entry (64 hex chars)
  command_hash?: string;           // SHA-256 of the command entry
  prompt_hash?: string;            // SHA-256 of the prompt entry (medium+ assurance)
  reasoning_hash?: string;         // SHA-256 of the reasoning entry (high assurance)
  action: VibesAction;             // What operation was performed
  timestamp: string;               // ISO 8601 when the annotation was created
  commit_hash?: string;            // Git commit hash if available
  session_id?: string;             // Maestro session ID
  assurance_level: VibesAssuranceLevel;
}
```

### Function Annotation

Links a named function to provenance metadata. Used when function-level granularity is available (e.g., from AST analysis or tool metadata).

```typescript
interface VibeFunctionAnnotation {
  type: 'function';
  file_path: string;               // Path to the file containing the function
  function_name: string;           // Function/method name
  function_signature?: string;     // Full signature, e.g. "function foo(x: number): string"
  environment_hash: string;        // SHA-256 of the environment entry
  command_hash?: string;           // SHA-256 of the command entry
  prompt_hash?: string;            // SHA-256 of the prompt entry
  reasoning_hash?: string;         // SHA-256 of the reasoning entry
  action: VibesAction;             // What operation was performed
  timestamp: string;               // ISO 8601 timestamp
  commit_hash?: string;            // Git commit hash if available
  session_id?: string;             // Maestro session ID
  assurance_level: VibesAssuranceLevel;
}
```

### Session Record

Marks the start or end of an AI agent session. Session records bracket the annotations produced within a session, enabling session-scoped queries.

```typescript
interface VibesSessionRecord {
  type: 'session';
  event: 'start' | 'end';
  session_id: string;              // UUID generated by Maestro
  timestamp: string;               // ISO 8601 timestamp
  environment_hash?: string;       // Set on 'start'; optional on 'end'
  assurance_level?: VibesAssuranceLevel;  // Set on 'start'
  description?: string;            // e.g. "claude-code agent session"
}
```

### Action Types

The `action` field on line and function annotations describes what the AI agent did to the code:

```typescript
type VibesAction = 'create' | 'modify' | 'delete' | 'review';
```

| Action | Meaning |
|---|---|
| `create` | New file or code block created by the agent |
| `modify` | Existing code edited or patched by the agent |
| `delete` | Code or file removed by the agent |
| `review` | Code read or inspected without modification |

## Manifest Entry Types

Manifest entries are content-addressed records stored in `manifest.json`. Each entry is keyed by its SHA-256 hash (see [Hash Specification](#hash-specification)), enabling deduplication and tamper-evident linking from annotations.

```typescript
type VibesManifestEntry =
  | VibesEnvironmentEntry
  | VibesCommandEntry
  | VibesPromptEntry
  | VibesReasoningEntry;
```

### Environment Entry

Records the tool and model environment that produced annotations. Every session starts with an environment entry.

```typescript
interface VibesEnvironmentEntry {
  type: 'environment';
  tool_name: string;                          // e.g. "Claude Code", "Codex", "Maestro"
  tool_version: string;                       // e.g. "1.2.3"
  model_name: string;                         // e.g. "claude-4", "o3"
  model_version: string;                      // e.g. "opus"
  model_parameters?: Record<string, unknown>; // e.g. { temperature: 0.7, top_p: 0.9 }
  tool_extensions?: string[];                 // e.g. ["mcp-server", "memory"]
  created_at: string;                         // ISO 8601 timestamp
}
```

### Command Entry

Records a command executed by the AI agent. Captured at all assurance levels, with output summaries at medium and above.

```typescript
interface VibesCommandEntry {
  type: 'command';
  command_text: string;                    // The command text (truncated to 200 chars)
  command_type: VibesCommandType;          // Classification of the command
  command_exit_code?: number;              // Process exit code if available
  command_output_summary?: string;         // Truncated output (max 200 chars)
  working_directory?: string;              // Working directory when executed
  created_at: string;                      // ISO 8601 timestamp
}
```

#### Command Type Classification

```typescript
type VibesCommandType =
  | 'shell'        // Shell/bash commands
  | 'file_write'   // File write or edit operations
  | 'file_read'    // File read operations
  | 'file_delete'  // File deletion
  | 'api_call'     // API calls (WebFetch, WebSearch)
  | 'tool_use'     // Generic tool use (search, todo, etc.)
  | 'other';       // Uncategorized
```

### Prompt Entry

Records a prompt that triggered agent activity. Only captured at medium and high assurance levels.

```typescript
interface VibesPromptEntry {
  type: 'prompt';
  prompt_text: string;                     // Full prompt text
  prompt_type?: VibesPromptType;           // Classification of the prompt
  prompt_context_files?: string[];         // Files referenced in the prompt context
  created_at: string;                      // ISO 8601 timestamp
}
```

#### Prompt Type Classification

```typescript
type VibesPromptType =
  | 'user_instruction'     // Direct user instruction
  | 'edit_command'         // Edit/modify directive
  | 'chat_message'        // Conversational message
  | 'inline_completion'   // Code completion request
  | 'review_request'      // Code review request
  | 'refactor_request'    // Refactoring request
  | 'other';              // Uncategorized
```

### Reasoning Entry

Records chain-of-thought output from the model. Only captured at high assurance level. Supports compression and external blob storage for large reasoning blocks.

```typescript
interface VibesReasoningEntry {
  type: 'reasoning';
  reasoning_text?: string;                 // Full text (if not compressed/externalized)
  reasoning_text_compressed?: string;      // Compressed text (if > compress threshold)
  compressed?: boolean;                    // Whether gzip compression was applied
  external?: boolean;                      // Whether stored in external blob
  blob_path?: string;                      // Path to blob file (e.g. "blobs/<hash>.bin")
  reasoning_token_count?: number;          // Token count from model usage event
  reasoning_model?: string;               // Model that generated the reasoning
  created_at: string;                      // ISO 8601 timestamp
}
```

#### Reasoning Storage Logic

```
if reasoning_text.length <= 10,240 bytes (compress threshold):
    Store inline as reasoning_text

if reasoning_text.length > 10,240 bytes:
    Compress with gzip → reasoning_text_compressed
    Set compressed: true

if compressed_size > 102,400 bytes (external blob threshold):
    Write to blobs/<hash>.bin
    Set external: true, blob_path: "blobs/<hash>.bin"
    Remove inline text fields
```

## Hash Specification

VIBES uses SHA-256 content-addressed hashing to deduplicate manifest entries and enable tamper-evident linking from annotations to their provenance data.

### Algorithm

1. **Remove temporal data**: Strip the `created_at` field from the entry object. This ensures identical content produces the same hash regardless of when it was created.
2. **Canonical serialization**: Serialize to JSON with **sorted keys** and **no whitespace** (`JSON.stringify` with sorted key list).
3. **Encode**: Encode the JSON string as UTF-8.
4. **Hash**: Compute SHA-256 of the UTF-8 bytes.
5. **Format**: Output as a lowercase hexadecimal string (64 characters).

### Implementation

```typescript
import { createHash } from 'node:crypto';

export function computeVibesHash(context: Record<string, unknown>): string {
  const { created_at: _, ...rest } = context;
  const serialized = JSON.stringify(rest, Object.keys(rest).sort());
  return createHash('sha256').update(serialized, 'utf8').digest('hex');
}

export function shortHash(hash: string): string {
  return hash.slice(0, 16);
}
```

### Properties

| Property | Description |
|---|---|
| **Deterministic** | Same content always produces the same hash |
| **Time-independent** | `created_at` is excluded, so timestamps don't affect the hash |
| **Key-order-independent** | Keys are sorted before serialization |
| **Deduplicating** | Identical entries produce the same hash and are stored once in the manifest |
| **Tamper-evident** | Any modification to an entry invalidates its hash |

### Format

- **Full hash**: 64 lowercase hexadecimal characters (`/^[0-9a-f]{64}$/`)
- **Short hash**: First 16 characters of the full hash (used for display in the UI)

### Known Test Vector

Input (canonical JSON, sorted keys, `created_at` removed):

```json
{"model_name":"claude-opus-4-5","tool_name":"Claude Code","tool_version":"1.0","type":"environment"}
```

SHA-256 result:

```
a8b293149a7c71409a38f036ebeeea25942bb92531fb8d74bbf3e48098c537ed
```

## File Formats

All VIBES data is stored in the `.ai-audit/` directory at the project root.

```
.ai-audit/
├── config.json           # Project-level VIBES configuration
├── manifest.json         # Content-addressed manifest entries
├── annotations.jsonl     # Append-only annotation log
└── blobs/                # External storage for large data
    └── <hash>.bin        # Compressed reasoning or large payloads
```

### config.json

Project-level VIBES configuration. Written as pretty-printed JSON (2-space indent, trailing newline).

```json
{
  "standard": "VIBES",
  "standard_version": "1.0",
  "assurance_level": "medium",
  "project_name": "my-project",
  "tracked_extensions": [".ts", ".tsx", ".js", ".jsx", ".py"],
  "exclude_patterns": ["**/node_modules/**", "**/.git/**"],
  "compress_reasoning_threshold_bytes": 10240,
  "external_blob_threshold_bytes": 102400
}
```

#### Schema

```typescript
interface VibesConfig {
  standard: 'VIBES';
  standard_version: '1.0';
  assurance_level: VibesAssuranceLevel;
  project_name: string;
  tracked_extensions: string[];
  exclude_patterns: string[];
  compress_reasoning_threshold_bytes: number;
  external_blob_threshold_bytes: number;
}
```

### manifest.json

Content-addressed manifest storing all provenance entries. Written as pretty-printed JSON (2-space indent, trailing newline). Entries are keyed by their SHA-256 hash.

```json
{
  "standard": "VIBES",
  "version": "1.0",
  "entries": {
    "a8b293149a7c71409a38f036ebeeea25942bb92531fb8d74bbf3e48098c537ed": {
      "type": "environment",
      "tool_name": "Claude Code",
      "tool_version": "1.0",
      "model_name": "claude-opus-4-5",
      "model_version": "opus",
      "created_at": "2026-02-10T12:00:00.000Z"
    },
    "fc29a1b3...": {
      "type": "command",
      "command_text": "npm test",
      "command_type": "shell",
      "command_exit_code": 0,
      "command_output_summary": "All tests passed",
      "created_at": "2026-02-10T12:01:00.000Z"
    }
  }
}
```

#### Schema

```typescript
interface VibesManifest {
  standard: 'VIBES';
  version: '1.0';
  entries: Record<string, VibesManifestEntry>;
}
```

**Deduplication behavior**: When `addManifestEntry` is called, the entry's hash is computed. If the hash already exists in the manifest, the entry is not duplicated. New entries are merged into the existing manifest object.

### annotations.jsonl

Line-delimited JSON file containing annotations. Each line is a valid JSON object representing one annotation. The file is append-only — new annotations are written by appending lines, never by rewriting.

```jsonl
{"type":"session","event":"start","session_id":"550e8400-e29b-41d4-a716-446655440000","timestamp":"2026-02-10T12:00:00.000Z","environment_hash":"a8b293...","assurance_level":"medium"}
{"type":"line","file_path":"src/index.ts","line_start":10,"line_end":25,"environment_hash":"a8b293...","command_hash":"fc29a1...","action":"modify","timestamp":"2026-02-10T12:01:00.000Z","session_id":"550e8400-e29b-41d4-a716-446655440000","assurance_level":"medium"}
{"type":"function","file_path":"src/utils.ts","function_name":"parseConfig","environment_hash":"a8b293...","action":"create","timestamp":"2026-02-10T12:02:00.000Z","session_id":"550e8400-e29b-41d4-a716-446655440000","assurance_level":"medium"}
{"type":"session","event":"end","session_id":"550e8400-e29b-41d4-a716-446655440000","timestamp":"2026-02-10T12:30:00.000Z"}
```

#### Format Rules

- One JSON object per line (no multi-line JSON)
- Trailing newline after each entry
- Blank lines are ignored when reading
- No array wrapper — each line is independent
- Concurrent-safe: multiple writers can append without coordination

### blobs/ Directory

External storage for large payloads that exceed the blob threshold (default: 100 KB). Files are named by the SHA-256 hash of their content with a `.bin` extension.

```
blobs/
├── 7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069.bin
└── ...
```

## Maestro-Specific Extensions

Maestro extends the base VIBES v1.0 standard with a two-layer instrumentation architecture and cross-agent session correlation.

### Two-Layer Instrumentation

| Layer | Tool Name | What It Captures |
|---|---|---|
| **Layer 1 — Orchestration** | `"Maestro"` | Agent spawn events, batch run lifecycle, high-level prompt dispatch, completion status |
| **Layer 2 — Tool Execution** | `"Claude Code"`, `"Codex"` | Individual tool executions, file modifications, shell commands, reasoning chains |

**Layer 1** answers: "What agents were dispatched, with what prompts, and what were the outcomes?"

**Layer 2** answers: "What specific files were read, written, or modified, and what reasoning drove those changes?"

Both layers write to the same `.ai-audit/` directory, and annotations from both layers can reference the same session ID.

### Event-to-VIBES Mapping

Maestro's ProcessManager emits events that the VibesCoordinator routes to the appropriate instrumenter:

| ProcessManager Event | Instrumenter | VIBES Output |
|---|---|---|
| `tool-execution` (Claude Code tools) | Claude Code Instrumenter | Command entry + line/function annotation |
| `tool-execution` (Codex tools) | Codex Instrumenter | Command entry + line/function annotation |
| `thinking-chunk` | Active instrumenter | Buffered; flushed as reasoning entry on next tool execution |
| `usage` | Active instrumenter | Token counts and model info attached to reasoning entry |
| `exit` | VibesCoordinator | Session end record |
| Agent spawn (Maestro-level) | Maestro Instrumenter | Command + prompt entries |
| Agent complete (Maestro-level) | Maestro Instrumenter | Command entry with exit code |

### Claude Code Tool Mapping

| Claude Code Tool | VIBES Command Type | VIBES Action |
|---|---|---|
| Write | `file_write` | `create` |
| Edit, MultiEdit, NotebookEdit | `file_write` | `modify` |
| Read | `file_read` | `review` |
| Bash | `shell` | varies |
| Glob, Grep, TodoRead, TodoWrite, Task | `tool_use` | varies |
| WebFetch, WebSearch | `api_call` | varies |

**File path extraction**: Reads `file_path`, `path`, or `notebook_path` from tool parameters.
**Line range extraction**: Reads `offset`/`limit` or `cell_number` fields.
**Command text**: Extracted from `command` field (Bash tools), truncated to 200 characters.

### Codex Tool Mapping

| Codex Tool | VIBES Command Type | VIBES Action |
|---|---|---|
| shell, container_shell | `shell` | varies |
| write_file, apply_patch | `file_write` | `modify` |
| create_file | `file_write` | `create` |
| read_file, list_directory | `file_read` | `review` |
| file_search, grep_search, codebase_search | `tool_use` | varies |

**File path extraction**: Reads `file_path`, `path`, `filename`, or `target_file` from tool parameters.
**Shell command extraction**: Reads `command` or `cmd` fields.

### Session State Tracking

Maestro maintains per-session state internally to track active instrumentation sessions:

```typescript
interface VibesSessionState {
  sessionId: string;                      // Maestro session ID
  vibesSessionId: string;                 // UUID for VIBES session record
  projectPath: string;                    // Absolute path to the project
  agentType: string;                      // 'claude-code', 'codex', etc.
  assuranceLevel: VibesAssuranceLevel;    // Inherited from config
  environmentHash: string | null;         // Set after environment entry is created
  annotationCount: number;                // Running count of annotations in this session
  startedAt: string;                      // ISO 8601 timestamp
  isActive: boolean;                      // Session lifecycle flag
}
```

### Per-Agent Configuration

Maestro supports enabling or disabling VIBES instrumentation per agent type independently:

```typescript
vibesPerAgentConfig: {
  'claude-code': { enabled: true },
  'codex': { enabled: true }
}
```

When an agent type is disabled, the VibesCoordinator skips routing events from that agent to its instrumenter. Maestro orchestration events (Layer 1) are controlled separately via the `vibesMaestroOrchestrationEnabled` setting.

### Reasoning Buffering

Reasoning capture follows a buffering strategy unique to Maestro's event-driven architecture:

1. `thinking-chunk` events accumulate text in a per-session buffer.
2. `usage` events provide token counts and model identification, which are cached.
3. When the next `tool-execution` event arrives (or the session ends), the buffer is flushed as a reasoning manifest entry.
4. The resulting reasoning hash is attached to the subsequent annotation.

This ensures reasoning is linked to the tool execution it informed, not the one that preceded it.
